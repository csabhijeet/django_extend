Proposal: Introducing @super_init Decorator in Django
Introduction
Django extensively uses object-oriented programming (OOP) principles, including class inheritance. One common practice is calling super().__init__() to ensure parent class initialization. While this approach maintains inheritance hierarchy, it also introduces unnecessary complexity and performance overhead, especially when dealing with API calls or resource-heavy tasks inside __init__.
This proposal suggests introducing a @super_init decorator in Django to provide more flexibility and better control over when the parent __init__ should execute. This will simplify Djangoâ€™s inheritance model, making code more readable, maintainable, and efficient.
________________________________________
The Current Approach and Its Limitations
Currently, Django relies on super().__init__() inside __init__ methods to ensure proper inheritance. However, this approach has several problems and limitations:
ðŸ”¹ 1. Forced Execution of Parent __init__
â€¢	Every time a child class is instantiated, super().__init__() is called automatically.
â€¢	This results in unnecessary execution of parent initialization, even when it is not needed.
Example from Django's Source Code: MiddlewareMixin
class MiddlewareMixin:
    def __init__(self, get_response=None):
        super().__init__()
        self.get_response = get_response
Problem: Every middleware instance executes super().__init__(), even when the parent initialization is not required.
________________________________________
ðŸ”¹ 2. API Calls and Heavy Computation in __init__
â€¢	It is not recommended to perform API calls or database queries inside __init__ due to performance issues.
â€¢	Developers must move API calls out of __init__ and call them separately, making code less intuitive.
Example: Heavy API Call in __init__
class ExpensiveModel:
    def __init__(self):
        super().__init__()
        self.data = requests.get('https://example.com/api/data').json()
Problem: Every instance makes an API call, leading to unnecessary network requests.
________________________________________
ðŸ”¹ 3. Complexity in Multi-Level Inheritance
When multiple levels of inheritance exist, managing super().__init__() becomes cumbersome and error-prone.
Example: Multi-Level Inheritance in Django
class Base:
    def __init__(self):
        super().__init__()
        print("Base Init")

class Parent(Base):
    def __init__(self):
        super().__init__()
        print("Parent Init")

class Child(Parent):
    def __init__(self):
        super().__init__()
        print("Child Init")
Problem: Each level forcibly calls super().__init__(), even when it's not needed, making the flow complex.
________________________________________
Proposed Solution: @super_init Decorator
We propose a @super_init decorator that allows selective execution of the parent __init__, providing more control over class initialization.
Implementation of @super_init Decorator
from functools import wraps

def super_init(cls):
    """Decorator to allow optional execution of parent __init__."""
    original_init = cls.__init__
    
    @wraps(original_init)
    def new_init(self, *args, **kwargs):
        if kwargs.pop('use_super', False):
            super(cls, self).__init__(*args, **kwargs)
        original_init(self, *args, **kwargs)
    
    cls.__init__ = new_init
    return cls
________________________________________
Rewriting the Examples with @super_init
ðŸ”¹ Simplifying Middleware Initialization
Before:
class MiddlewareMixin:
    def __init__(self, get_response=None):
        super().__init__()
        self.get_response = get_response
After Using @super_init:
@super_init
class MiddlewareMixin:
    def __init__(self, get_response=None, use_super=False):
        self.get_response = get_response
Benefit: Middleware can now skip unnecessary super().__init__() calls, improving performance.
________________________________________
ðŸ”¹ Handling API Calls Efficiently
Before:
class ExpensiveModel:
    def __init__(self):
        super().__init__()
        self.data = requests.get('https://example.com/api/data').json()
After Using @super_init:
@super_init
class ExpensiveModel:
    def __init__(self, use_super=False):
        if use_super:
            self.data = requests.get('https://example.com/api/data').json()
Benefit: We can control when API calls execute, reducing unnecessary network requests.
________________________________________
ðŸ”¹ Reducing Complexity in Multi-Level Inheritance
Before:
class Base:
    def __init__(self):
        super().__init__()
        print("Base Init")
After Using @super_init:
@super_init
class Base:
    def __init__(self, use_super=False):
        if use_super:
            print("Base Init")
Benefit: Child classes can now choose whether to run parent __init__, improving flexibility.
________________________________________
What This Will Bring to Djangoâ€™s Future
âœ… Key Benefits
1.	Improves Performance â€“ Avoids unnecessary method calls.
2.	Enhances Flexibility â€“ Developers decide when to execute parent initialization.
3.	Simplifies Inheritance â€“ Reduces multi-level complexity.
4.	More Readable & Maintainable Code â€“ Avoids redundant logic.
________________________________________
Potential Challenges and Counterarguments
Potential Issue	Counterargument
Not Python Standard â€“ This changes Djangoâ€™s inheritance model.	@super_init is optional and aligns with Pythonic principles of explicit control.
Breaks Method Resolution Order (MRO)?	MRO remains intact, as @super_init only controls __init__ execution.
Learning Curve â€“ New developers might not understand use_super.	Proper documentation and Django tutorials can clarify its use case.
________________________________________
Conclusion: Why Django Should Adopt This
This proposal introduces a practical enhancement to Djangoâ€™s inheritance mechanism by adding @super_init, allowing developers to skip unnecessary parent initialization while maintaining the flexibility to invoke it when needed.
By implementing this, Django can make its models, middleware, and class-based views more efficient, leading to better performance and code maintainability.
Would love to hear feedback from the Django community on this!

